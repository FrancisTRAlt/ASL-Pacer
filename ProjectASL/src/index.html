<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <link rel="stylesheet" href="styles.css" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ASL Pacer</title>

  <script src="./lib/p5.min.js"></script>
  <script src="./lib/ml5.min.js"></script>
  <script src="./lib/supabase.js"></script>
</head>

<body>
  <!-- Your sketch -->
   <script src="./main.js"></script>

  <!-- Hidden YouTube player (playback only; not analyzable) -->
  <div id="yt-music-player" style="width:1px;height:1px;position:absolute;left:-9999px;top:-9999px;"></div>

  <!-- Real media element for analysis and playback of direct audio URLs -->
  <audio id="ap-audio" crossorigin="anonymous" preload="auto" hidden></audio>

  <script>
    // 1) Load the YouTube IFrame API (for YT playback)
    (function loadYTAPI() {
      var tag = document.createElement('script');
      tag.src = "https://www.youtube.com/iframe_api";
      var firstScript = document.getElementsByTagName('script')[0];
      firstScript.parentNode.insertBefore(tag, firstScript);
    })();

    // 2) bgMusic facade supports TWO modes:
    //    - "audio": a real <audio> element (analyzable; drives the visualizer)
    //    - "youtube": hidden iframe (plays, but NOT analyzable)
    const audioEl = document.getElementById('ap-audio');

    // Internal state
    let mode = "audio";     // "audio" or "youtube"
    let ytPlayer = null;
    let autoLoop = true;

    // Keep flags consistent across modes
    const state = { ready: false, paused: true, muted: true };

    // -- AUDIO ELEMENT EVENTS (analysis-capable source) --
    audioEl.addEventListener('loadedmetadata', () => { state.ready = true; });
    audioEl.addEventListener('canplay', () => { state.ready = true; });
    audioEl.addEventListener('play', () => { state.paused = false; });
    audioEl.addEventListener('pause', () => { state.paused = true; });
    audioEl.addEventListener('ended', () => { if (autoLoop) { audioEl.currentTime = 0; audioEl.play(); } });

    // 3) Facade expected by main.js
    window.bgMusic = {
      get ready() { return state.ready; },
      isPaused() { return state.paused; },
      isMuted() { return state.muted; },

      play() { mode === "audio" ? audioEl.play().catch(() => { }) : ytPlayer?.playVideo(); state.paused = false; },
      pause() { mode === "audio" ? audioEl.pause() : ytPlayer?.pauseVideo(); state.paused = true; },

      setMuted(m) {
        state.muted = !!m;
        if (mode === "audio") {
          audioEl.muted = state.muted;
        } else if (ytPlayer) {
          state.muted ? ytPlayer.mute() : ytPlayer.unMute();
        }
      },

      setVolume(percent) {
        const v = Math.max(0, Math.min(100, Number(percent || 0))) / 100;
        if (mode === "audio") {
          audioEl.volume = v;
        } else if (ytPlayer) {
          ytPlayer.setVolume(Math.round(v * 100));
        }
      },

      setLoopEnabled(on) { autoLoop = !!on; },

      // IMPORTANT: This decides which backend to use:
      //  - direct audio URL -> uses <audio> (visualizer ON)
      //  - YouTube URL/ID   -> uses iframe (visualizer OFF; console warns)
      cue(raw) {
        const s = String(raw || "").trim();
        if (!s) return;

        // Try to detect a direct audio URL (analysis-capable)
        const isAudioUrl = /^(https?:\/\/|\/).+\.(mp3|ogg|wav|m4a)(\?.*)?$/i.test(s);
        if (isAudioUrl) {
          mode = "audio";
          // Ensure crossorigin for analysis (requires server CORS)
          audioEl.crossOrigin = audioEl.crossOrigin || "anonymous";
          audioEl.src = s;
          state.ready = false;
          audioEl.load(); // will fire canplay/loadedmetadata
          // Start muted to satisfy autoplay policies in main.js flow
          audioEl.muted = true;
          state.muted = true;
          state.paused = true;
          return;
        }

        // Otherwise treat as YouTube (ID or URL)
        mode = "youtube";
        if (!ytPlayer) {
          console.warn('[bgMusic] YouTube selected; visualizer will be disabled (iframe audio is not analyzable).');
        } else {
          // If the string looks like a full URL, extract the ID via regex
          const match = s.match(/(?:v=|\/embed\/|youtu\.be\/|\/shorts\/)([A-Za-z0-9_\-]{6,})/);
          const id = match ? match[1] : s;
          ytPlayer.cueVideoById(id);
          state.paused = true;
          state.muted = true;
          ytPlayer.mute();
        }
      },

      // main.js uses this to build the Web Audio graph; return <audio> only in audio mode
      getMediaElement() { return mode === "audio" ? audioEl : null; }
    };

    // 4) YouTube player init (playback only; not analyzable)
    function onYouTubeIframeAPIReady() {
      ytPlayer = new YT.Player('yt-music-player', {
        height: '200', width: '200',
        videoId: "", // harmless default
        playerVars: { autoplay: 0, controls: 0, rel: 0, modestbranding: 1, playsinline: 1 },
        events: {
          onReady: function (e) {
            e.target.mute(); // policy-friendly
            state.ready = true;
            state.paused = true;
            state.muted = true;
          },
          onStateChange: function (ev) {
            if (ev.data === YT.PlayerState.PLAYING) state.paused = false;
            if (ev.data === YT.PlayerState.PAUSED) state.paused = true;
            if (ev.data === YT.PlayerState.ENDED && autoLoop) ytPlayer.playVideo();
          }
        }
      });
    }
    window.onYouTubeIframeAPIReady = onYouTubeIframeAPIReady;
  </script>
</body>
</html>